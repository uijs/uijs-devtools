var boxcars = (function(undefined){

  var slice = Array.prototype.slice,
      node  = typeof process != 'undefined' && process.versions && process.versions.node != undefined,
      get   = node && nodeGet || browserGet,

      XHR, libhttp, libhttps, liburl, libfs;

  if(node){

    libhttp  = require('http');
    libhttps = require('https');
    liburl   = require('url');
    libfs    = require('fs');

  } else if (typeof XMLHttpRequest != "undefined"){

    XHR = XMLHttpRequest;

  } else {

    XHR = function XMLHttpRequest() {
      try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); }
      catch (e) {}
      try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); }
      catch (e) {}
      try { return new ActiveXObject("Microsoft.XMLHTTP"); }
      catch (e) {}
      throw new Error("This browser does not support XMLHttpRequest.");
    };

  };

  function isArray(el){
    return Object.prototype.toString.call(el) == '[object Array]';
  }

  function browserGet(url, callback){
    var req = new XHR;

    req.open('GET', url, true);

    req.onreadystatechange = function (aEvt) {
      if ( req.readyState == 4 ) {
        if ( req.status == 200 ){
          callback(undefined, req.responseText);
        } else {
          callback(new Error('GET ' + url + ' has been failed (' + req.status + ')'));
        }
      }
    };

    req.send();
  };

  function nodeGet(uri, callback){
    return ( /^\w+\:\/\//.test(uri) && nodeHttpGet || nodeFSGet ).apply(undefined, arguments);
  }

  function nodeFSGet(filename, callback){
    libfs.readFile(filename, function(error, bf){
      if(error){
        callback(error);
        return;
      }

      callback(undefined, bf.toString());
    });
  }

  function nodeHttpGet(url, callback){
    var urlopts = liburl.parse(url);
    var host = urlopts.host.replace(/\:\d+/, ''),
        options = {
          host: host,
          port: urlopts.port,
          path: urlopts.pathname,
          headers: {
            Host: host
          }
        };

    ( urlopts.protocol == 'https' && libhttps || libhttp ).get(options, function(res) {
      var buffer = '';
      res.setEncoding('utf8');
      res.on('data', function (chunk) {
        buffer += chunk;
      });

      res.on('end', function(){
        callback(undefined, buffer);
      });
    });
  }


  return function boxcarsColl(){
    var parentPaths = slice.call(arguments);

    var cache = (function(newValue){

      var elements = undefined;

      return function cache(newValue){

        if( arguments.length > 0 ){
          elements = newValue;
        }

        if( elements == undefined){
          elements = {};
        }

        return elements;
      };

    })();

    function element(path, callback){
      if( cache().hasOwnProperty(path) ){
        callback(undefined, cache()[path]);
        return;
      }

      get(path, function(error, content){
        if(!error){
          cache()[ path ] = content;
        }

        callback(error, content);
      });
    }

    function main(){
      var paths           = parentPaths.concat( slice.call(arguments, 0, arguments.length - 1) ),
          callback        = arguments[arguments.length - 1],

          isSingleContent = paths.length == 1 && typeof paths[0] == 'string',
          
          isListContent, isObjectContent,
          filenames, contents, map, key;

      paths.length == 1 && !isSingleContent && ( paths = paths[0] );

      isListContent = isArray(paths);
      isObjectContent = !isListContent && typeof paths == 'object' && paths.hasOwnProperty != undefined;

      if( isListContent ){
        filenames = paths;
        contents = [];
      } else {
        filenames = [];
        contents  = {};
        map       = {};

        for(key in paths){
          filenames.push( paths[key] );
          
          map[ paths[key] ] = key;
          contents[ key ] = undefined;
        }

      }

      (function iter(i){

        if( i >= filenames.length ){
          callback( undefined, contents );
          return;
        }

        element(filenames[i], function(error, content){
          
          if(error){
            callback(error);
            return;
          } else if( isSingleContent ){
            callback(undefined, content);
            return;
          } else if( isListContent ){
            contents.push( content );
          } else {
            contents[ map[filenames[i]] ] = content;
          }

          iter(i+1);

        });

      }(0));

    }

    main.cache = cache;

    return main;
  };

})();

if(typeof module != 'undefined' && module.exports){
  module.exports = boxcars;
}
